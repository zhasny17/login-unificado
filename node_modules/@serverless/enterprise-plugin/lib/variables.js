'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const _ = require('lodash');

const _require = require('@serverless/platform-sdk'),
      getStateVariable = _require.getStateVariable;

module.exports.hookIntoVariableGetter = (ctx, secrets, accessKey) => {
  const getValueFromSource = ctx.sls.variables.getValueFromSource;

  ctx.sls.variables.getValueFromSource =
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(function* (variableString) {
      if (variableString.startsWith('secrets:')) {
        ctx.state.secretsUsed.add(variableString.substring(8));

        if (ctx.sls.processedInput.commands[0] === 'login' || ctx.sls.processedInput.commands[0] === 'logout') {
          return {};
        }

        if (!secrets[variableString.split('secrets:')[1]]) {
          throw new Error(`$\{${variableString}} not defined`);
        }

        return secrets[variableString.split('secrets:')[1]];
      } else if (variableString.startsWith('state:')) {
        if (ctx.sls.processedInput.commands[0] === 'login' || ctx.sls.processedInput.commands[0] === 'logout') {
          return {};
        }

        const service = variableString.substring(6).split('.', 1)[0];
        const key = variableString.substring(6).substr(service.length);
        const outputName = key.split('.')[1];
        const subkey = key.substr(outputName.length + 2);

        const _ref2 = yield getStateVariable({
          accessKey,
          outputName,
          service,
          app: ctx.sls.service.app,
          tenant: ctx.sls.service.tenant,
          stage: ctx.provider.getStage(),
          region: ctx.provider.getRegion()
        }),
              value = _ref2.value;

        if (subkey) {
          return _.get(value, subkey);
        }

        return value;
      }

      const value = getValueFromSource.bind(ctx.sls.variables)(variableString);
      return value;
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(); // return a restore function (mostly for testing)


  return () => {
    ctx.sls.variables.getValueFromSource = getValueFromSource;
  };
};
//# sourceMappingURL=variables.js.map